<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Constraint Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Constraint.html">Constraint</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classghost_1_1Constraint-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Constraint Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="constraint_8hpp_source.html">constraint.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ghost::Constraint:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Constraint__coll__graph.png" border="0" usemap="#ghost_1_1Constraint_coll__map" alt="Collaboration graph"/></div>
<map name="ghost_1_1Constraint_coll__map" id="ghost_1_1Constraint_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,160,259"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a0ce33ef3a11dcfd39d9ca693eb2ac4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a4a0ce33ef3a11dcfd39d9ca693eb2ac4">Constraint</a> (const std::vector&lt; int &gt; &amp;variables_index)</td></tr>
<tr class="separator:a4a0ce33ef3a11dcfd39d9ca693eb2ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd3d18cb5a5859e61ffa6929e6baf47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#adcd3d18cb5a5859e61ffa6929e6baf47">Constraint</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables)</td></tr>
<tr class="separator:adcd3d18cb5a5859e61ffa6929e6baf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f4e85434d02d6fe0a2a95fa7ff6a56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a12f4e85434d02d6fe0a2a95fa7ff6a56">Constraint</a> (const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;other)=default</td></tr>
<tr class="memdesc:a12f4e85434d02d6fe0a2a95fa7ff6a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <a href="classghost_1_1Constraint.html#a12f4e85434d02d6fe0a2a95fa7ff6a56">More...</a><br /></td></tr>
<tr class="separator:a12f4e85434d02d6fe0a2a95fa7ff6a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90f09c362cb7eea3f92ed2814f26f20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#af90f09c362cb7eea3f92ed2814f26f20">Constraint</a> (<a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:af90f09c362cb7eea3f92ed2814f26f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <a href="classghost_1_1Constraint.html#af90f09c362cb7eea3f92ed2814f26f20">More...</a><br /></td></tr>
<tr class="separator:af90f09c362cb7eea3f92ed2814f26f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002177e11deecee2db240c9ff4647008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a002177e11deecee2db240c9ff4647008">operator=</a> (const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;other)=delete</td></tr>
<tr class="memdesc:a002177e11deecee2db240c9ff4647008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <a href="classghost_1_1Constraint.html#a002177e11deecee2db240c9ff4647008">More...</a><br /></td></tr>
<tr class="separator:a002177e11deecee2db240c9ff4647008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d220b6c65e9c5456bdbc49944a0b52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a2d220b6c65e9c5456bdbc49944a0b52c">operator=</a> (<a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:a2d220b6c65e9c5456bdbc49944a0b52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <a href="classghost_1_1Constraint.html#a2d220b6c65e9c5456bdbc49944a0b52c">More...</a><br /></td></tr>
<tr class="separator:a2d220b6c65e9c5456bdbc49944a0b52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea8263c24d0c3a5328c20ee0006f32"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#aebea8263c24d0c3a5328c20ee0006f32">~Constraint</a> ()=default</td></tr>
<tr class="memdesc:aebea8263c24d0c3a5328c20ee0006f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <a href="classghost_1_1Constraint.html#aebea8263c24d0c3a5328c20ee0006f32">More...</a><br /></td></tr>
<tr class="separator:aebea8263c24d0c3a5328c20ee0006f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a99bfdee12754330fd394ab4efbd93b41"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">required_error</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables) const =0</td></tr>
<tr class="separator:a99bfdee12754330fd394ab4efbd93b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e9147f88ec9aa5ebc452a4d64d8b5f"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a65e9147f88ec9aa5ebc452a4d64d8b5f">optional_delta_error</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, const std::vector&lt; int &gt; &amp;indexes, const std::vector&lt; int &gt; &amp;candidate_values) const</td></tr>
<tr class="separator:a65e9147f88ec9aa5ebc452a4d64d8b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5896a07e6089554c132f5a52ab6c7ece"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a5896a07e6089554c132f5a52ab6c7ece">conditional_update_data_structures</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int index, int new_value)</td></tr>
<tr class="separator:a5896a07e6089554c132f5a52ab6c7ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db724b023b1f69d13d7fc07baa02da4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a7db724b023b1f69d13d7fc07baa02da4">get_current_error</a> () const</td></tr>
<tr class="separator:a7db724b023b1f69d13d7fc07baa02da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e1434d1a8b408a59b03d031c054db3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a15e1434d1a8b408a59b03d031c054db3">get_id</a> () const</td></tr>
<tr class="memdesc:a15e1434d1a8b408a59b03d031c054db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline method to get the unique id of the <a class="el" href="classghost_1_1Constraint.html">Constraint</a> object.  <a href="classghost_1_1Constraint.html#a15e1434d1a8b408a59b03d031c054db3">More...</a><br /></td></tr>
<tr class="separator:a15e1434d1a8b408a59b03d031c054db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class from which users need to derive their <a class="el" href="classghost_1_1Constraint.html">Constraint</a> classes.</p>
<p><a class="el" href="classghost_1_1Constraint.html">ghost::Constraint</a> cannot be directly used to encode user-defined constrains, since this is an abstract class. To declare a problem with GHOST, users have to make their own derived constraint classes.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html">Variable</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a0ce33ef3a11dcfd39d9ca693eb2ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a0ce33ef3a11dcfd39d9ca693eb2ac4">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with a vector of variable IDs. This vector is internally used by <a class="el" href="classghost_1_1Constraint.html">Constraint</a> to know what variables from the global variable vector it is handling. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference to a vector of IDs of variables composing the constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcd3d18cb5a5859e61ffa6929e6baf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd3d18cb5a5859e61ffa6929e6baf47">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor building a vector of variable IDs by calling v-&gt;<a class="el" href="classghost_1_1Constraint.html#a15e1434d1a8b408a59b03d031c054db3" title="Inline method to get the unique id of the Constraint object.">get_id()</a> from all variables v.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference to a vector of variable composing the constraint. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12f4e85434d02d6fe0a2a95fa7ff6a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12f4e85434d02d6fe0a2a95fa7ff6a56">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy contructor. </p>

</div>
</div>
<a id="af90f09c362cb7eea3f92ed2814f26f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af90f09c362cb7eea3f92ed2814f26f20">&#9670;&nbsp;</a></span>Constraint() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Constraint::Constraint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move contructor. </p>

</div>
</div>
<a id="aebea8263c24d0c3a5328c20ee0006f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebea8263c24d0c3a5328c20ee0006f32">&#9670;&nbsp;</a></span>~Constraint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ghost::Constraint::~Constraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5896a07e6089554c132f5a52ab6c7ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5896a07e6089554c132f5a52ab6c7ece">&#9670;&nbsp;</a></span>conditional_update_data_structures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Constraint::conditional_update_data_structures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update user-defined data structures in the constraint.</p>
<p>Like any methods prefixed by 'conditional_', this method must be overriden under some conditions: if some inner data structures are defined in derived constraint classes and need to be updated while variable values change (i.e., when the solver asssign 'new_value' to variables[index]), this method must be implemented to define how data structures must be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables of the constraint. </td></tr>
    <tr><td class="paramname">index</td><td>an integer to get the variable 'variables[index]' that has been updated by the solver. </td></tr>
    <tr><td class="paramname">new_value</td><td>an integer to know what is the new value of 'variables[index]'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7db724b023b1f69d13d7fc07baa02da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db724b023b1f69d13d7fc07baa02da4">&#9670;&nbsp;</a></span>get_current_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::Constraint::get_current_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline method returning the current error of the constraint (automatically updated by the solver). This can be helpful for implementing optional_delta_error. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Constraint.html#a65e9147f88ec9aa5ebc452a4d64d8b5f">optional_delta_error</a> </dd></dl>

</div>
</div>
<a id="a15e1434d1a8b408a59b03d031c054db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15e1434d1a8b408a59b03d031c054db3">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ghost::Constraint::get_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline method to get the unique id of the <a class="el" href="classghost_1_1Constraint.html">Constraint</a> object. </p>

</div>
</div>
<a id="a002177e11deecee2db240c9ff4647008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002177e11deecee2db240c9ff4647008">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Constraint.html">Constraint</a>&amp; ghost::Constraint::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator disabled. </p>

</div>
</div>
<a id="a2d220b6c65e9c5456bdbc49944a0b52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d220b6c65e9c5456bdbc49944a0b52c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Constraint.html">Constraint</a>&amp; ghost::Constraint::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator disabled. </p>

</div>
</div>
<a id="a65e9147f88ec9aa5ebc452a4d64d8b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e9147f88ec9aa5ebc452a4d64d8b5f">&#9670;&nbsp;</a></span>optional_delta_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Constraint::optional_delta_error </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to compute the difference, or delta, between the current error and the error of a candidate assignment.</p>
<p>The current assignment, as well as its error, are automatically stored in the class <a class="el" href="classghost_1_1Constraint.html">Constraint</a>. Giving a vector of variable indexes and their respective candidate value, this methods ouputs the difference between the error of the current assignment in 'variables' given as input and the error we would get if we assign new candidate values.</p>
<p>The ouput can be negative, positive, or equals to 0. If the candidate error is strictly lower (then better) than the current error, the ouput is negative. If errors are the same, the ouputs equals to 0. Finally, if the candidate error is strictly higher (then worth) than the current error, the ouput is positive.</p>
<p>For EFSP/EFOP models, this method can be VERY important to have faster computation. Although optional (the solver still works without it), we strongly advise users to define it properly, unless the overridden required_error method is trivial to compute. Having this method may make a big difference for the solver to quickly find better solutions. However, if the problem is modeled as an CSP/COP, users can just skip the implementation of this method.</p>
<p>Like any methods prefixed by 'optional_', overriding this method is not mandatory.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT implement any side effect in this method. It is called by the solver to compute the constraint delta error but also for some inner mechanisms (such as error simulations).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">indexes</td><td>the vector of indexes of variables that are reassigned. </td></tr>
    <tr><td class="paramname">candidate_values</td><td>the vector of their respective candidate values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double corresponding to the difference between the current error of the constraint and the error one would get if the solver assigns candidate values to given variables. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is NaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99bfdee12754330fd394ab4efbd93b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99bfdee12754330fd394ab4efbd93b41">&#9670;&nbsp;</a></span>required_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Constraint::required_error </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual method to compute the error of the constraint regarding the values of variables given as input.</p>
<p>This method is fundamental: as a predicate, it evalutes if the given values of variables violate this contraint, and as an error function, it evaluates how much.<br  />
Let's consider the following example to understand error functions: consider the contraint (x = y).<br  />
If x = 42 and y = 42, then these values satify the contraint. The error is then 0.<br  />
If x = 42 and y = 40, the constraint is not satified, but intuitively, we are closer to have a solution than with x = 42 and y = 10,000. Thus the error when y = 40 must be strictly lower than the error when y = 10,000.<br  />
Thus, a required_error candidate for the contraint (x = y) could be the function |x-y|.</p>
<p>This method MUST returns a value greater than or equals to 0.</p>
<p>Users have the choice: while modeling CSP or COP problems, required_error must implement the logic of a predicate and should outputs 0 if current values of variables satisfy the user-defined constraint, and something strictly higher than 0 otherwise, like 1 for instance.</p>
<p>While modeling EFSP/EFOP problems, required_error needs to express an error function. It still must outputs 0 for satisfying values of variables, but must outputs a value strictly higher than 0 otherwise, such that the higher this value, the further current values of variables are from satisfying the user-defined constraint.</p>
<p>Like any methods prefixed by 'required_', overriding this method is mandatory.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT implement any side effect in this method. It is called by the solver to compute the constraint error but also for some inner mechanisms (such as error simulations).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <b>positive</b> double corresponding to the error of the constraint. Outputing 0 means that given variable values satisfy the constraint. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is negative or is NaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="constraint_8hpp_source.html">constraint.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 4 2021 11:12:21 for GHOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
