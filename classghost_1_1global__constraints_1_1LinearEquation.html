<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::global_constraints::LinearEquation Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="namespaceghost_1_1global__constraints.html">global_constraints</a></li><li class="navelem"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html">LinearEquation</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classghost_1_1global__constraints_1_1LinearEquation-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ghost::global_constraints::LinearEquation Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="linear__equation_8hpp_source.html">linear_equation.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ghost::global_constraints::LinearEquation:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1global__constraints_1_1LinearEquation__inherit__graph.png" border="0" usemap="#aghost_1_1global__constraints_1_1LinearEquation_inherit__map" alt="Inheritance graph"/></div>
<map name="aghost_1_1global__constraints_1_1LinearEquation_inherit__map" id="aghost_1_1global__constraints_1_1LinearEquation_inherit__map">
<area shape="rect" title=" " alt="" coords="461,373,620,568"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationEq.html" title=" " alt="" coords="5,616,164,756"/>
<area shape="poly" title=" " alt="" coords="449,503,318,552,246,583,177,618,166,625,163,620,174,614,243,578,316,547,448,498"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationG.html" title=" " alt="" coords="188,616,347,756"/>
<area shape="poly" title=" " alt="" coords="452,544,349,625,345,621,449,540"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationGeq.html" title=" " alt="" coords="371,616,529,756"/>
<area shape="poly" title=" " alt="" coords="497,582,482,617,477,615,492,580"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationL.html" title=" " alt="" coords="553,616,712,756"/>
<area shape="poly" title=" " alt="" coords="590,580,605,615,600,617,585,582"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationLeq.html" title=" " alt="" coords="736,616,895,756"/>
<area shape="poly" title=" " alt="" coords="633,540,737,621,734,625,629,544"/>
<area shape="rect" href="classghost_1_1global__constraints_1_1LinearEquationNeq.html" title=" " alt="" coords="919,616,1077,756"/>
<area shape="poly" title=" " alt="" coords="634,498,766,546,839,578,909,614,920,620,917,625,906,618,837,583,764,551,632,503"/>
<area shape="rect" href="classghost_1_1Constraint.html" title=" " alt="" coords="467,5,614,325"/>
<area shape="poly" title=" " alt="" coords="543,339,543,373,538,373,538,339"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for ghost::global_constraints::LinearEquation:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1global__constraints_1_1LinearEquation__coll__graph.png" border="0" usemap="#aghost_1_1global__constraints_1_1LinearEquation_coll__map" alt="Collaboration graph"/></div>
<map name="aghost_1_1global__constraints_1_1LinearEquation_coll__map" id="aghost_1_1global__constraints_1_1LinearEquation_coll__map">
<area shape="rect" title=" " alt="" coords="5,373,164,568"/>
<area shape="rect" href="classghost_1_1Constraint.html" title=" " alt="" coords="11,5,158,325"/>
<area shape="poly" title=" " alt="" coords="87,339,87,373,82,373,82,339"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aea1d9021ae729ddf132aa0c312be3348" id="r_aea1d9021ae729ddf132aa0c312be3348"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#aea1d9021ae729ddf132aa0c312be3348">LinearEquation</a> (const std::vector&lt; int &gt; &amp;variables_index, double <a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a7eeec95883abcf88b2fc8dd19ed3f49b">rhs</a>, const std::vector&lt; double &gt; &amp;coefficients)</td></tr>
<tr class="separator:aea1d9021ae729ddf132aa0c312be3348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb9ffab0c31d91b6b01a39f54c04bbf" id="r_a3cb9ffab0c31d91b6b01a39f54c04bbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a3cb9ffab0c31d91b6b01a39f54c04bbf">LinearEquation</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, double <a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a7eeec95883abcf88b2fc8dd19ed3f49b">rhs</a>, const std::vector&lt; double &gt; &amp;coefficients)</td></tr>
<tr class="separator:a3cb9ffab0c31d91b6b01a39f54c04bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0730d24ee1b81b097d1bde29dc4714" id="r_a9a0730d24ee1b81b097d1bde29dc4714"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a9a0730d24ee1b81b097d1bde29dc4714">compute_error</a> (double sum) const =0</td></tr>
<tr class="separator:a9a0730d24ee1b81b097d1bde29dc4714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29ccffdc1b7fc60390d39f90dbbcdf7" id="r_aa29ccffdc1b7fc60390d39f90dbbcdf7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#aa29ccffdc1b7fc60390d39f90dbbcdf7">required_error</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables) const override</td></tr>
<tr class="separator:aa29ccffdc1b7fc60390d39f90dbbcdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cdd10dfaaeaaabe0a0c31522955749" id="r_a39cdd10dfaaeaaabe0a0c31522955749"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a39cdd10dfaaeaaabe0a0c31522955749">optional_delta_error</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, const std::vector&lt; int &gt; &amp;variable_indexes, const std::vector&lt; int &gt; &amp;candidate_values) const override</td></tr>
<tr class="separator:a39cdd10dfaaeaaabe0a0c31522955749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3abd0aa97c8cdaafb7c93cbc1df6b8" id="r_a8f3abd0aa97c8cdaafb7c93cbc1df6b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a8f3abd0aa97c8cdaafb7c93cbc1df6b8">conditional_update_data_structures</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int variable_id, int new_value) override</td></tr>
<tr class="separator:a8f3abd0aa97c8cdaafb7c93cbc1df6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classghost_1_1Constraint"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classghost_1_1Constraint')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classghost_1_1Constraint.html">ghost::Constraint</a></td></tr>
<tr class="memitem:a7db724b023b1f69d13d7fc07baa02da4 inherit pro_methods_classghost_1_1Constraint" id="r_a7db724b023b1f69d13d7fc07baa02da4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a7db724b023b1f69d13d7fc07baa02da4">get_current_error</a> () const</td></tr>
<tr class="separator:a7db724b023b1f69d13d7fc07baa02da4 inherit pro_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15e1434d1a8b408a59b03d031c054db3 inherit pro_methods_classghost_1_1Constraint" id="r_a15e1434d1a8b408a59b03d031c054db3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a15e1434d1a8b408a59b03d031c054db3">get_id</a> () const</td></tr>
<tr class="memdesc:a15e1434d1a8b408a59b03d031c054db3 inherit pro_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline method to get the unique id of the <a class="el" href="classghost_1_1Constraint.html">Constraint</a> object.  <br /></td></tr>
<tr class="separator:a15e1434d1a8b408a59b03d031c054db3 inherit pro_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7eeec95883abcf88b2fc8dd19ed3f49b" id="r_a7eeec95883abcf88b2fc8dd19ed3f49b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1global__constraints_1_1LinearEquation.html#a7eeec95883abcf88b2fc8dd19ed3f49b">rhs</a></td></tr>
<tr class="separator:a7eeec95883abcf88b2fc8dd19ed3f49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_methods_classghost_1_1Constraint"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classghost_1_1Constraint')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classghost_1_1Constraint.html">ghost::Constraint</a></td></tr>
<tr class="memitem:a4a0ce33ef3a11dcfd39d9ca693eb2ac4 inherit pub_methods_classghost_1_1Constraint" id="r_a4a0ce33ef3a11dcfd39d9ca693eb2ac4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a4a0ce33ef3a11dcfd39d9ca693eb2ac4">Constraint</a> (const std::vector&lt; int &gt; &amp;variables_index)</td></tr>
<tr class="separator:a4a0ce33ef3a11dcfd39d9ca693eb2ac4 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd3d18cb5a5859e61ffa6929e6baf47 inherit pub_methods_classghost_1_1Constraint" id="r_adcd3d18cb5a5859e61ffa6929e6baf47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#adcd3d18cb5a5859e61ffa6929e6baf47">Constraint</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables)</td></tr>
<tr class="separator:adcd3d18cb5a5859e61ffa6929e6baf47 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f4e85434d02d6fe0a2a95fa7ff6a56 inherit pub_methods_classghost_1_1Constraint" id="r_a12f4e85434d02d6fe0a2a95fa7ff6a56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a12f4e85434d02d6fe0a2a95fa7ff6a56">Constraint</a> (const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;other)=default</td></tr>
<tr class="memdesc:a12f4e85434d02d6fe0a2a95fa7ff6a56 inherit pub_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <br /></td></tr>
<tr class="separator:a12f4e85434d02d6fe0a2a95fa7ff6a56 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90f09c362cb7eea3f92ed2814f26f20 inherit pub_methods_classghost_1_1Constraint" id="r_af90f09c362cb7eea3f92ed2814f26f20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#af90f09c362cb7eea3f92ed2814f26f20">Constraint</a> (<a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:af90f09c362cb7eea3f92ed2814f26f20 inherit pub_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <br /></td></tr>
<tr class="separator:af90f09c362cb7eea3f92ed2814f26f20 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabce8013b33aa807f95c101fd7d43e2 inherit pub_methods_classghost_1_1Constraint" id="r_afabce8013b33aa807f95c101fd7d43e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#afabce8013b33aa807f95c101fd7d43e2">operator=</a> (const <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;other)=delete</td></tr>
<tr class="memdesc:afabce8013b33aa807f95c101fd7d43e2 inherit pub_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <br /></td></tr>
<tr class="separator:afabce8013b33aa807f95c101fd7d43e2 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add451dd206e71383b6506608dd907404 inherit pub_methods_classghost_1_1Constraint" id="r_add451dd206e71383b6506608dd907404"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#add451dd206e71383b6506608dd907404">operator=</a> (<a class="el" href="classghost_1_1Constraint.html">Constraint</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:add451dd206e71383b6506608dd907404 inherit pub_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <br /></td></tr>
<tr class="separator:add451dd206e71383b6506608dd907404 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebea8263c24d0c3a5328c20ee0006f32 inherit pub_methods_classghost_1_1Constraint" id="r_aebea8263c24d0c3a5328c20ee0006f32"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#aebea8263c24d0c3a5328c20ee0006f32">~Constraint</a> ()=default</td></tr>
<tr class="memdesc:aebea8263c24d0c3a5328c20ee0006f32 inherit pub_methods_classghost_1_1Constraint"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <br /></td></tr>
<tr class="separator:aebea8263c24d0c3a5328c20ee0006f32 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e91a2a917f9bd6b4f3f5f59960a86b7 inherit pub_methods_classghost_1_1Constraint" id="r_a3e91a2a917f9bd6b4f3f5f59960a86b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Constraint.html#a3e91a2a917f9bd6b4f3f5f59960a86b7">has_variable</a> (int var_id) const</td></tr>
<tr class="separator:a3e91a2a917f9bd6b4f3f5f59960a86b7 inherit pub_methods_classghost_1_1Constraint"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aea1d9021ae729ddf132aa0c312be3348" name="aea1d9021ae729ddf132aa0c312be3348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea1d9021ae729ddf132aa0c312be3348">&#9670;&#160;</a></span>LinearEquation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::global_constraints::LinearEquation::LinearEquation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cb9ffab0c31d91b6b01a39f54c04bbf" name="a3cb9ffab0c31d91b6b01a39f54c04bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb9ffab0c31d91b6b01a39f54c04bbf">&#9670;&#160;</a></span>LinearEquation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::global_constraints::LinearEquation::LinearEquation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a0730d24ee1b81b097d1bde29dc4714" name="a9a0730d24ee1b81b097d1bde29dc4714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0730d24ee1b81b097d1bde29dc4714">&#9670;&#160;</a></span>compute_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::global_constraints::LinearEquation::compute_error </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sum</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f3abd0aa97c8cdaafb7c93cbc1df6b8" name="a8f3abd0aa97c8cdaafb7c93cbc1df6b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3abd0aa97c8cdaafb7c93cbc1df6b8">&#9670;&#160;</a></span>conditional_update_data_structures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::global_constraints::LinearEquation::conditional_update_data_structures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update user-defined data structures in the constraint.</p>
<p>Like any methods prefixed by 'conditional_', this method must be overriden under some conditions: if some inner data structures are defined in derived constraint classes and need to be updated while variable values change (i.e., when the solver asssign 'new_value' to variables[index]), this method must be implemented to define how data structures must be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables of the constraint. </td></tr>
    <tr><td class="paramname">index</td><td>an integer to get the variable 'variables[index]' that has been updated by the solver. </td></tr>
    <tr><td class="paramname">new_value</td><td>an integer to know what is the new value of 'variables[index]'. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classghost_1_1Constraint.html#a5896a07e6089554c132f5a52ab6c7ece">ghost::Constraint</a>.</p>

</div>
</div>
<a id="a39cdd10dfaaeaaabe0a0c31522955749" name="a39cdd10dfaaeaaabe0a0c31522955749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cdd10dfaaeaaabe0a0c31522955749">&#9670;&#160;</a></span>optional_delta_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::global_constraints::LinearEquation::optional_delta_error </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to compute the difference, or delta, between the current error and the error of a candidate assignment.</p>
<p>The current assignment, as well as its error, are automatically stored in the class <a class="el" href="classghost_1_1Constraint.html">Constraint</a>. Giving a vector of variable indexes and their respective candidate value, this methods ouputs the difference between the error of the current assignment in 'variables' given as input and the error we would get if we assign new candidate values.</p>
<p>The ouput can be negative, positive, or equals to 0. If the candidate error is strictly lower (then better) than the current error, the ouput is negative. If errors are the same, the ouputs equals to 0. Finally, if the candidate error is strictly higher (then worst) than the current error, the ouput is positive.</p>
<p>For EF-CSP/EF-COP models, this method can be VERY important to have faster computation. Although optional (the solver still works without it), we strongly advise users to define it properly, unless the overridden required_error method is trivial to compute. Having this method may make a big difference for the solver to quickly find better solutions. However, if the problem is modeled as an CSP/COP, users can just skip the implementation of this method.</p>
<p>Like any methods prefixed by 'optional_', overriding this method is not mandatory.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT implement any side effect in this method. It is called by the solver to compute the constraint delta error but also for some inner mechanisms (such as error simulations).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">indexes</td><td>the vector of indexes of variables that are reassigned. </td></tr>
    <tr><td class="paramname">candidate_values</td><td>the vector of their respective candidate values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double corresponding to the difference between the current error of the constraint and the error one would get if the solver assigns candidate values to given variables. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classghost_1_1Constraint.html#a65e9147f88ec9aa5ebc452a4d64d8b5f">ghost::Constraint</a>.</p>

</div>
</div>
<a id="aa29ccffdc1b7fc60390d39f90dbbcdf7" name="aa29ccffdc1b7fc60390d39f90dbbcdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29ccffdc1b7fc60390d39f90dbbcdf7">&#9670;&#160;</a></span>required_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::global_constraints::LinearEquation::required_error </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual method to compute the error of the constraint regarding the values of variables given as input.</p>
<p>This method is fundamental: as a predicate, it evalutes if the given values of variables violate this contraint, and as an error function, it evaluates how much.<br  />
Let's consider the following example to understand error functions: consider the contraint (x = y).<br  />
If x = 42 and y = 42, then these values satify the contraint. The error is then 0.<br  />
If x = 42 and y = 40, the constraint is not satified, but intuitively, we are closer to have a solution than with x = 42 and y = 10,000. Thus the error when y = 40 must be strictly lower than the error when y = 10,000.<br  />
Thus, a required_error candidate for the contraint (x = y) could be the function |x-y|.</p>
<p>This method MUST returns a value greater than or equals to 0.</p>
<p>Users have the choice: while modeling CSP or COP problems, required_error must implement the logic of a predicate and should outputs 0 if current values of variables satisfy the user-defined constraint, and something strictly higher than 0 otherwise, like 1 for instance.</p>
<p>While modeling EF-CSP/EF-COP problems, required_error needs to express an error function. It still must outputs 0 for satisfying values of variables, but must outputs a value strictly higher than 0 otherwise, such that the higher this value, the further current values of variables are from satisfying the user-defined constraint.</p>
<p>Like any methods prefixed by 'required_', overriding this method is mandatory.</p>
<dl class="section warning"><dt>Warning</dt><dd>DO NOT implement any side effect in this method. It is called by the solver to compute the constraint error but also for some inner mechanisms (such as error simulations).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <b>positive</b> double corresponding to the error of the constraint. Outputing 0 means that given variable values satisfy the constraint. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is negative or is NaN. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">ghost::Constraint</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7eeec95883abcf88b2fc8dd19ed3f49b" name="a7eeec95883abcf88b2fc8dd19ed3f49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eeec95883abcf88b2fc8dd19ed3f49b">&#9670;&#160;</a></span>rhs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::global_constraints::LinearEquation::rhs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="linear__equation_8hpp_source.html">linear_equation.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 4 2025 12:54:27 for GHOST by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
