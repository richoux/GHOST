<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Solver&lt; ModelBuilderType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Solver.html">Solver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classghost_1_1Solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Solver&lt; ModelBuilderType &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="solver_8hpp_source.html">solver.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ghost::Solver&lt; ModelBuilderType &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Solver__coll__graph.png" border="0" usemap="#aghost_1_1Solver_3_01ModelBuilderType_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="aghost_1_1Solver_3_01ModelBuilderType_01_4_coll__map" id="aghost_1_1Solver_3_01ModelBuilderType_01_4_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,192,185"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0143b99bbc018bf4aae1f88fd28bdb44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a0143b99bbc018bf4aae1f88fd28bdb44">Solver</a> (const ModelBuilderType &amp;model_builder)</td></tr>
<tr class="separator:a0143b99bbc018bf4aae1f88fd28bdb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07445e3d720b2138d52d46ffb655e00f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">fast_search</a> (double &amp;final_cost, std::vector&lt; int &gt; &amp;final_solution, double timeout, <a class="el" href="structghost_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a07445e3d720b2138d52d46ffb655e00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708fccd3a3bc1434082557467633fab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a708fccd3a3bc1434082557467633fab9">fast_search</a> (double &amp;final_cost, std::vector&lt; int &gt; &amp;final_solution, double timeout)</td></tr>
<tr class="separator:a708fccd3a3bc1434082557467633fab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa296c97a6512cebd0f81363decfb3e70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#aa296c97a6512cebd0f81363decfb3e70">fast_search</a> (double &amp;final_cost, std::vector&lt; int &gt; &amp;final_solution, std::chrono::microseconds timeout, <a class="el" href="structghost_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:aa296c97a6512cebd0f81363decfb3e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3c96e4eb6e55e38ad0a880adc1092e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a0c3c96e4eb6e55e38ad0a880adc1092e">fast_search</a> (double &amp;final_cost, std::vector&lt; int &gt; &amp;final_solution, std::chrono::microseconds timeout)</td></tr>
<tr class="separator:a0c3c96e4eb6e55e38ad0a880adc1092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10085964774e00d35e4e1a651535e27a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a10085964774e00d35e4e1a651535e27a">complete_search</a> (std::vector&lt; double &gt; &amp;final_costs, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;final_solutions, <a class="el" href="structghost_1_1Options.html">Options</a> &amp;options)</td></tr>
<tr class="separator:a10085964774e00d35e4e1a651535e27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dff70b13a068fd5877741cc4533935"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#af5dff70b13a068fd5877741cc4533935">get_variables</a> ()</td></tr>
<tr class="separator:af5dff70b13a068fd5877741cc4533935"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ModelBuilderType&gt;<br />
class ghost::Solver&lt; ModelBuilderType &gt;</h3>

<p><a class="el" href="classghost_1_1Solver.html">Solver</a> is the class coding the solver itself.</p>
<p>To solve a problem instance, users must instanciate a <a class="el" href="classghost_1_1Solver.html">Solver</a> object, then run <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a>. This will search for a good quality solution within a given timeout. If all solutions of a problem are required, or if the optimality of the solution must be certified, then users can run Solver::complete_search instead. Notice that this will run a significantly slower search method and is only viable on small problem instances.</p>
<p>The unique <a class="el" href="classghost_1_1Solver.html">Solver</a> constructor needs a derived <a class="el" href="classghost_1_1ModelBuilder.html">ghost::ModelBuilder</a> object, as well as an optional boolean indicating if the solver is dealing with a permutation problem, i.e., if the solver needs to swap variable values instead of picking new values from domains.</p>
<p>Declaring combinatorial problems as permutation problems can lead to a huge performance boost for the solver. For this, the problem needs to be declared with all variables starting with a value that belongs to a solution.</p>
<p>This is typically the case for scheduling problems, for instance: imagine we want to do three tasks A, B and C. Thus, we give A as the starting value to the first variable, B to the second and C to the third. Then, instead of assigning the task A to the second variable for instance, the solver will swap tasks of the first and the second variables.</p>
<p>Users are invited to model as much as possible their problems as permutation problems, since it would greatly speed-up the search of solutions.</p>
<p>Many options compiled in a <a class="el" href="structghost_1_1Options.html">ghost::Options</a> object can be passed to methods <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> / Solver::complete_search, to allow for instance parallel computing, as well as parameter tweaking for local search experts.</p>
<p><a class="el" href="classghost_1_1Solver.html">ghost::Solver</a> is a template class, although users should never need to instantiate the template with modern C++ compilers.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1ModelBuilder.html">ModelBuilder</a>, <a class="el" href="structghost_1_1Options.html">Options</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0143b99bbc018bf4aae1f88fd28bdb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0143b99bbc018bf4aae1f88fd28bdb44">&#9670;&nbsp;</a></span>Solver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::<a class="el" href="classghost_1_1Solver.html">Solver</a> </td>
          <td>(</td>
          <td class="paramtype">const ModelBuilderType &amp;&#160;</td>
          <td class="paramname"><em>model_builder</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unique constructor of <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model_builder</td><td>a const reference to a derived <a class="el" href="classghost_1_1ModelBuilder.html">ModelBuilder</a> object. </td></tr>
    <tr><td class="paramname">permutation_problem</td><td>a boolean indicating if the solver will work on a permutation problem. False by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a10085964774e00d35e4e1a651535e27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10085964774e00d35e4e1a651535e27a">&#9670;&nbsp;</a></span>complete_search()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::complete_search </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_costs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>final_solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structghost_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to look for all solutions of a given CSP/COP/EF-CSP/EF-COP model.</p>
<p>This method returns true if at least one solution of the problem exists, and flase otherwise. It will write the error/cost of all solutions in the final_costs parameter, and all solutions themselves in the final_solutions parameter.<br  />
For a satisfaction problem (without any objective function), the error of a candidate is the sum of the error of each problem constraint (computated by <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>). For an optimization problem, the cost is the value outputed by <a class="el" href="classghost_1_1Objective.html#a8de169b534833805ae0073dc2ef22a6a">Objective::required_cost</a>.<br  />
For both, the lower value the better: A satisfaction error of 0 means we have a solution to a satisfaction problem (ie, all constraints are satisfied). An optimization cost should be as low as possible: GHOST is always trying to minimize problems. If you have a maximization problem, GHOST will automatically convert it into a minimization problem.</p>
<p>Finally, options to change the solver behaviors (parallel runs, user-defined solution printing) can be given as a last parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_costs</td><td>a reference to a vector of double to get the errors of all solutions for satisfaction problems, or their objective function value for optimization problems For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">final_solutions</td><td>a reference to a vector of vector of integers, containing all solutions of the problem instance. </td></tr>
    <tr><td class="paramname">options</td><td>a reference to an <a class="el" href="structghost_1_1Options.html">Options</a> object containing options such as parallel runs, a solution printer, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only a solution of the problem exists. </dd></dl>

</div>
</div>
<a id="a708fccd3a3bc1434082557467633fab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708fccd3a3bc1434082557467633fab9">&#9670;&nbsp;</a></span>fast_search() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::fast_search </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>final_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> with default options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_cost</td><td>a reference to a double to get the error of the best candidate or solution for satisfaction problems, or the objective function value of the best solution for optimization problems (or the cost of the best candidate if no solution has been found). For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">final_solution</td><td>a reference to a vector of integers, to get values of the best candidate or solution found. </td></tr>
    <tr><td class="paramname">timeout</td><td>a double for the time budget allowed to the solver to find a solution, in microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if a solution has been found. </dd></dl>

</div>
</div>
<a id="a07445e3d720b2138d52d46ffb655e00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07445e3d720b2138d52d46ffb655e00f">&#9670;&nbsp;</a></span>fast_search() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::fast_search </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>final_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structghost_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to quickly solve the given CSP/COP/EF-CSP/EF-COP model. Users should favor the two versions of <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> taking a std::chrono::microseconds value as a parameter.</p>
<p>This method is the heart of GHOST's solver: it will try to find a solution within a limited time. If it finds such a solution, the function outputs the value true.<br  />
Here how it works: if at least one solution is found, at the end of the computation, it will write in the two first parameters final_cost and final_solution the error/cost of the best candidate or solution found and the value of each variable.<br  />
For a satisfaction problem (without any objective function), the error of a candidate is the sum of the error of each problem constraint (computated by <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>). For an optimization problem, the cost is the value outputed by <a class="el" href="classghost_1_1Objective.html#a8de169b534833805ae0073dc2ef22a6a">Objective::required_cost</a>.<br  />
For both, the lower value the better: A satisfaction error of 0 means we have a solution to a satisfaction problem (ie, all constraints are satisfied). An optimization cost should be as low as possible: GHOST is always trying to minimize problems. If you have a maximization problem, GHOST will automatically convert it into a minimization problem.</p>
<p>The timeout parameter is fundamental: it represents a time budget, in microseconds, for the solver. The behavior will differ from satisfaction and optimization problems.</p>
<p>For satisfaction problems modeled with an CSP or EF-CSP, the solver stops as soon as it finds a solution. Then, it outputs 'true', writes 0 into the final_cost variable and the values of the variables composing the solution into the final_solution vector.<br  />
If no solutions are found within the timeout, the solver stops, outputs 'false', writes in final_cost the error of the best candidate found during the search (i.e., the candidate being the closest from a solution) and writes the best candidate's values into the final_solution vector.</p>
<p>For optimization problems modeled with an COP or EF-COP, the solver will always continue running until reaching the timeout. If a solution is found, it outputs 'true' and writes into the final_cost variable the cost of the best solution optimizating the given objective function. It also writes the values of the solution into the final_solution vector.<br  />
If no solutions are found, the solver outputs 'false' and adopt the same behavior as not finding a solution for satisfaction problems.</p>
<p>Finally, options to change the solver behaviors (parallel runs, user-defined solution printing, user-defined starting candidate, parameter tweaking, etc) can be given as a last parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_cost</td><td>a reference to a double to get the error of the best candidate or solution for satisfaction problems, or the objective function value of the best solution for optimization problems (or the cost of the best candidate if no solution has been found). For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">final_solution</td><td>a reference to a vector of integers, to get values of the best candidate or solution found. </td></tr>
    <tr><td class="paramname">timeout</td><td>a double for the time budget allowed to the solver to find a solution, in microseconds. </td></tr>
    <tr><td class="paramname">options</td><td>a reference to an <a class="el" href="structghost_1_1Options.html">Options</a> object containing options such as parallel runs, a solution printer, if the solver must start with a custom variable assignment, parameter tuning, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if a solution has been found. </dd></dl>

</div>
</div>
<a id="a0c3c96e4eb6e55e38ad0a880adc1092e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3c96e4eb6e55e38ad0a880adc1092e">&#9670;&nbsp;</a></span>fast_search() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::fast_search </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>final_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> with a chrono literal timeout in microseconds and default options.</p>
<p>Users should favor this <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> method if they want default options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_cost</td><td>a reference to a double to get the error of the best candidate or solution for satisfaction problems, or the objective function value of the best solution for optimization problems (or the cost of the best candidate if no solution has been found). For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">final_solution</td><td>a reference to a vector of integers, to get values of the best candidate or solution found. </td></tr>
    <tr><td class="paramname">timeout</td><td>a std::chrono::microseconds for the time budget allowed to the solver to find a solution. Higher std::chrono durations (such as milliseconds, seconds, etc) would be automatically converted into microseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if a solution has been found. </dd></dl>

</div>
</div>
<a id="aa296c97a6512cebd0f81363decfb3e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa296c97a6512cebd0f81363decfb3e70">&#9670;&nbsp;</a></span>fast_search() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::fast_search </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>final_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>final_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::microseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structghost_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> with a chrono literal timeout in microseconds.</p>
<p>Users should favor this <a class="el" href="classghost_1_1Solver.html#a07445e3d720b2138d52d46ffb655e00f">Solver::fast_search</a> method if they need to give the solver user-defined options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">final_cost</td><td>a reference to a double to get the error of the best candidate or solution for satisfaction problems, or the objective function value of the best solution for optimization problems (or the cost of the best candidate if no solution has been found). For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">final_solution</td><td>a reference to a vector of integers, to get values of the best candidate or solution found. </td></tr>
    <tr><td class="paramname">timeout</td><td>a std::chrono::microseconds for the time budget allowed to the solver to find a solution. Higher std::chrono durations (such as milliseconds, seconds, etc) would be automatically converted into microseconds. </td></tr>
    <tr><td class="paramname">options</td><td>a reference to an <a class="el" href="structghost_1_1Options.html">Options</a> object containing options such as parallel runs, a solution printer, if the solver must start with a custom variable assignment, parameter tuning, etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if and only if a solution has been found. </dd></dl>

</div>
</div>
<a id="af5dff70b13a068fd5877741cc4533935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dff70b13a068fd5877741cc4533935">&#9670;&nbsp;</a></span>get_variables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classghost_1_1Variable.html">Variable</a>&gt; <a class="el" href="classghost_1_1Solver.html">ghost::Solver</a>&lt; ModelBuilderType &gt;::get_variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Method to get the variables in the model. This method can be handy in some situations, if users do not know what the variables composing their problem instance are, and need them number in their programs. </p><dl class="section return"><dt>Returns</dt><dd>A vector of the <a class="el" href="classghost_1_1Variable.html">Variable</a> objects composing the model variables. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="solver_8hpp_source.html">solver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 20 2023 18:43:24 for GHOST by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
