<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Solver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Solver.html">Solver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classghost_1_1Solver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Solver Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a> is the class coding the solver itself.  
 <a href="classghost_1_1Solver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="solver_8hpp_source.html">solver.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ghost::Solver:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Solver__coll__graph.png" border="0" usemap="#ghost_1_1Solver_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a08cd6511d8f11a1b78a6e46c9f02ec8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a08cd6511d8f11a1b78a6e46c9f02ec8a">Solver</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;vecVariables, vector&lt; shared_ptr&lt; <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;vecConstraints, shared_ptr&lt; <a class="el" href="classghost_1_1Objective.html">Objective</a> &gt; objective, bool permutationProblem=false)</td></tr>
<tr class="memdesc:a08cd6511d8f11a1b78a6e46c9f02ec8a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s regular constructor.  <a href="#a08cd6511d8f11a1b78a6e46c9f02ec8a">More...</a><br /></td></tr>
<tr class="separator:a08cd6511d8f11a1b78a6e46c9f02ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fef29b475575713d7c507569e25976c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a8fef29b475575713d7c507569e25976c">Solver</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;vecVariables, vector&lt; shared_ptr&lt; <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;vecConstraints, bool permutationProblem=false)</td></tr>
<tr class="memdesc:a8fef29b475575713d7c507569e25976c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Second <a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s constructor, without <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a>.  <a href="#a8fef29b475575713d7c507569e25976c">More...</a><br /></td></tr>
<tr class="separator:a8fef29b475575713d7c507569e25976c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d21dccc6a803452a81839495294019"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Solver.html#a31d21dccc6a803452a81839495294019">solve</a> (double &amp;finalCost, vector&lt; int &gt; &amp;finalSolution, double sat_timeout, double opt_timeout=0., bool no_random_starting_point=false)</td></tr>
<tr class="memdesc:a31d21dccc6a803452a81839495294019"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s main function, to solve the given CSP/COP/CFN.  <a href="#a31d21dccc6a803452a81839495294019">More...</a><br /></td></tr>
<tr class="separator:a31d21dccc6a803452a81839495294019"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a> is the class coding the solver itself. </p>
<p>To solve a problem instance, you must instanciate a <a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a> object, then run <a class="el" href="classghost_1_1Solver.html#a31d21dccc6a803452a81839495294019" title="Solver&#39;s main function, to solve the given CSP/COP/CFN. ">Solver::solve</a>.</p>
<p><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a> constructors need a vector of <a class="el" href="classghost_1_1Variable.html" title="This class encodes variables of your CSP/COP/CFN. You cannot inherits your own class from Variable...">Variable</a>, a vector of shared pointers on <a class="el" href="classghost_1_1Constraint.html" title="This class encodes constraints of your CSP/COP/CFN. ">Constraint</a> objects, an optional shared pointer on an <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> object (the solver will create a special empty <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> object is none is given), and finally an optionnal boolean to indicate if the problem has been modeled as a permutation problem (false by default).</p>
<p>A permutation problem is a problem where all variables start with different values, and only swapping values is allowed. This is typically the case for scheduling problems, for instance: you want to do A first, then B second, C third, and so on. The solution of the problem must assign a unique value for each variable. Try as much as possible to model your problems as permutation problems, since it should greatly speed-up the search of solutions.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html" title="This class encodes variables of your CSP/COP/CFN. You cannot inherits your own class from Variable...">Variable</a>, <a class="el" href="classghost_1_1Constraint.html" title="This class encodes constraints of your CSP/COP/CFN. ">Constraint</a>, <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a08cd6511d8f11a1b78a6e46c9f02ec8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08cd6511d8f11a1b78a6e46c9f02ec8a">&#9670;&nbsp;</a></span>Solver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; shared_ptr&lt; <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vecConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">shared_ptr&lt; <a class="el" href="classghost_1_1Objective.html">Objective</a> &gt;&#160;</td>
          <td class="paramname"><em>objective</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permutationProblem</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s regular constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVariables</td><td>A reference to the vector of Variables. </td></tr>
    <tr><td class="paramname">vecConstraints</td><td>A reference to the vector of shared pointer of Constraints. </td></tr>
    <tr><td class="paramname">obj</td><td>A shared pointer to the <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a>. </td></tr>
    <tr><td class="paramname">permutationProblem</td><td>A boolean indicating if we work on a permutation problem. False by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fef29b475575713d7c507569e25976c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fef29b475575713d7c507569e25976c">&#9670;&nbsp;</a></span>Solver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Solver::Solver </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vecVariables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; shared_ptr&lt; <a class="el" href="classghost_1_1Constraint.html">Constraint</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vecConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>permutationProblem</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Second <a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s constructor, without <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecVariables</td><td>A reference to the vector of Variables. </td></tr>
    <tr><td class="paramname">vecConstraints</td><td>A reference to the vector of shared pointer of Constraints. </td></tr>
    <tr><td class="paramname">permutationProblem</td><td>A boolean indicating if we work on a permutation problem. False by default. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a31d21dccc6a803452a81839495294019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d21dccc6a803452a81839495294019">&#9670;&nbsp;</a></span>solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ghost::Solver::solve </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>finalCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>finalSolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sat_timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>opt_timeout</em> = <code>0.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_random_starting_point</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classghost_1_1Solver.html" title="Solver is the class coding the solver itself. ">Solver</a>'s main function, to solve the given CSP/COP/CFN. </p>
<p>This function is the heart of GHOST's solver: it will try to find a solution within a limited time. If it finds such a solution, the function outputs the value true.<br />
Here how it works: if at least one solution is found, at the end of the computation, it will write in the two first parameters finalCost and finalSolution the cost of the best solution found and the value of each variable.<br />
For a satisfaction problem (without any objective function), the cost of a solution is the sum of the cost of each problem constraint (computated by <a class="el" href="classghost_1_1Constraint.html#a6ef4cd03a4dc864a8d308e55044c615d" title="Pure virtual function to compute the current cost of the constraint. ">Constraint::required_cost</a>). For an optimization problem, the cost is the value outputed by <a class="el" href="classghost_1_1Objective.html#aae6630f4fca9012278a0bf1ca1503cd0" title="Pure virtual function to compute the value of the objective function on the current configuration...">Objective::required_cost</a>.<br />
For both, the lower value the better: A satisfaction cost of 0 means we have a solution to a satisfaction problem (ie, all constraints are satisfied). An optimization cost should be as low as possible: GHOST is handling minimization problems only. If you have a maximization problem (you are looking to the highest possible value of your objective function), look at the <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> documentation to see how to easily convert your problem into a minimization problem.</p>
<p>The two last parameters sat_timeout and opt_timeout are fundamental: sat_timeout is mandatory, opt_timeout is optional: if not given, its value will be fixed to sat_timeout * 10.<br />
sat_timeout is the timeout in microseconds you give to GHOST to find a solution to the problem, ie, finding a value for each variable such that each constraint of the problem is satisfied. For a satisfaction problem, this is the timeout within GHOST must output a solution.<br />
opt_timeout is only useful for optimization problems. Once GHOST finds a solution within sat_timeout, it saves it and try to find other solutions leading to better (ie, smaller) values of the objective function. Then it restarts a fresh satisfaction search, with once again sat_timeout as a timeout to find a solution. It will repeat this operation until opt_timeout is reached.</p>
<p>Thus for instance, if you set sat_timeout to 20μs and opt_timeout to 60μs (or bit more like 65μs, see why below), you let GHOST the time to run 3 satisfaction runs within a global runtime of 60μs (or 65μs), like illustrated below (with milliseconds instead of microseconds).</p>
<div class="image">
<img src="architecture.png" alt="architecture.png"/>
<div class="caption">
x and y milliseconds correspond respectively to sat_timeout and opt_timeout</div></div>
 It is possible it returns no solutions after timeout; in that case <a class="el" href="classghost_1_1Solver.html#a31d21dccc6a803452a81839495294019" title="Solver&#39;s main function, to solve the given CSP/COP/CFN. ">Solver::solve</a> returns false. If it is often the case, this is a strong evidence the satisfaction timeout is too low, and the solver does not have time to find at least one solution. Thus, this is the only parameter you may have to tweak in GHOST.</p>
<p>The illustration above shows satisfaction and optimization post-processes. The first one is triggered each time the solver found a solution. If the user overloads <a class="el" href="classghost_1_1Objective.html#ad8d0e06072e4167d6c2fd4df533fea9b" title="Virtual function to perform satisfaction post-processing. ">Objective::expert_postprocess_satisfaction</a>, he or she must be sure that his or her function runs very quickly, otherwise it may slow down the whole optimization process and may limit the number of solutions found by the solver. Optimization post-process runtime is not taken into account within opt_timeout, so the real GHOST runtime for optimization problems will be roughly equals to opt_timeout + optimization post-process runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">finalCost</td><td>A reference to the double of the sum of constraints cost for satisfaction problems, or the value of the objective function for optimization problems. For satisfaction problems, a cost of zero means a solution has been found. </td></tr>
    <tr><td class="paramname">finalSolution</td><td>The configuration of the best solution found, ie, a reference to the vector of assignements of each variable. </td></tr>
    <tr><td class="paramname">sat_timeout</td><td>The satisfaction timeout in microseconds. </td></tr>
    <tr><td class="paramname">opt_timeout</td><td>The optimization timeout in microseconds (optionnal, equals to 10 times sat_timeout is not set). </td></tr>
    <tr><td class="paramname">no_random_starting_point</td><td>A Boolean to indicate if the solver should not start from a random starting point. This is necessary in particular to use the resume feature. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True iff a solution has been found. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="solver_8hpp_source.html">solver.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 16 2020 15:40:10 for GHOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
