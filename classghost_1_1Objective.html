<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Objective Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Objective.html">Objective</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classghost_1_1Objective-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Objective Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="objective_8hpp_source.html">objective.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__inherit__graph.png" border="0" usemap="#ghost_1_1Objective_inherit__map" alt="Inheritance graph"/></div>
<map name="ghost_1_1Objective_inherit__map" id="ghost_1_1Objective_inherit__map">
<area shape="rect" title=" " alt="" coords="121,5,291,347"/>
<area shape="rect" href="classghost_1_1Maximize.html" title=" " alt="" coords="5,395,124,545"/>
<area shape="rect" href="classghost_1_1Minimize.html" title=" " alt="" coords="149,395,263,545"/>
<area shape="rect" href="classghost_1_1NullObjective.html" title=" " alt="" coords="288,431,428,509"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__coll__graph.png" border="0" usemap="#ghost_1_1Objective_coll__map" alt="Collaboration graph"/></div>
<map name="ghost_1_1Objective_coll__map" id="ghost_1_1Objective_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,176,347"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e2305f59de130a75785a1dc9269d7ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">Objective</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=default</td></tr>
<tr class="memdesc:a7e2305f59de130a75785a1dc9269d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <a href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">More...</a><br /></td></tr>
<tr class="separator:a7e2305f59de130a75785a1dc9269d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">Objective</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <a href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">More...</a><br /></td></tr>
<tr class="separator:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaedfb85e62325aaa1ce766e60c93d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">operator=</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=delete</td></tr>
<tr class="memdesc:adaedfb85e62325aaa1ce766e60c93d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <a href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">More...</a><br /></td></tr>
<tr class="separator:adaedfb85e62325aaa1ce766e60c93d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">operator=</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <a href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">More...</a><br /></td></tr>
<tr class="separator:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b288b785eb9abd31389adffe0e82716"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">~Objective</a> ()=default</td></tr>
<tr class="memdesc:a9b288b785eb9abd31389adffe0e82716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <a href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">More...</a><br /></td></tr>
<tr class="separator:a9b288b785eb9abd31389adffe0e82716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783eec9b238077a2b2f1b95aa9b9610e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a783eec9b238077a2b2f1b95aa9b9610e">get_name</a> () const</td></tr>
<tr class="memdesc:a783eec9b238077a2b2f1b95aa9b9610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline accessor to get the name of the objective object.  <a href="classghost_1_1Objective.html#a783eec9b238077a2b2f1b95aa9b9610e">More...</a><br /></td></tr>
<tr class="separator:a783eec9b238077a2b2f1b95aa9b9610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecd250b2a1c09c065942c4482b7b223"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adecd250b2a1c09c065942c4482b7b223">is_optimization</a> () const</td></tr>
<tr class="memdesc:adecd250b2a1c09c065942c4482b7b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline method returning if a user-defined objective function has been declared.  <a href="classghost_1_1Objective.html#adecd250b2a1c09c065942c4482b7b223">More...</a><br /></td></tr>
<tr class="separator:adecd250b2a1c09c065942c4482b7b223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2ff78a8bbaaf05db5a36e3e933023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af4e2ff78a8bbaaf05db5a36e3e933023">is_maximization</a> () const</td></tr>
<tr class="separator:af4e2ff78a8bbaaf05db5a36e3e933023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8de169b534833805ae0073dc2ef22a6a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a8de169b534833805ae0073dc2ef22a6a">required_cost</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables) const =0</td></tr>
<tr class="separator:a8de169b534833805ae0073dc2ef22a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eee4897bba29f5b14535cecb0afef35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a4eee4897bba29f5b14535cecb0afef35">conditional_update_data_structures</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int index, int new_value)</td></tr>
<tr class="separator:a4eee4897bba29f5b14535cecb0afef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d49dd27a72571e874351c8f969d2d43"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a7d49dd27a72571e874351c8f969d2d43">expert_heuristic_value</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int variable_index, const std::vector&lt; int &gt; &amp;possible_values) const</td></tr>
<tr class="separator:a7d49dd27a72571e874351c8f969d2d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a9c2bc85b6878e282fa4acd4e91085"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a74a9c2bc85b6878e282fa4acd4e91085">expert_heuristic_value_permutation</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int variable_index, const std::vector&lt; int &gt; &amp;bad_variables) const</td></tr>
<tr class="separator:a74a9c2bc85b6878e282fa4acd4e91085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6892d6c1c168b4a089e0bbea394e4e62"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a6892d6c1c168b4a089e0bbea394e4e62">expert_postprocess_satisfaction</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, double &amp;best_error, std::vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="separator:a6892d6c1c168b4a089e0bbea394e4e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10baf71ce9df56d6ad6a95878ca8cb96"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a10baf71ce9df56d6ad6a95878ca8cb96">expert_postprocess_optimization</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, double &amp;best_cost, std::vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="separator:a10baf71ce9df56d6ad6a95878ca8cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a9de70ecd5f26813a79db906a70f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ac49a9de70ecd5f26813a79db906a70f4">is_not_optimization</a> ()</td></tr>
<tr class="separator:ac49a9de70ecd5f26813a79db906a70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6e93affa93ccff08bcbcb65f9897f65c"><td class="memItemLeft" align="right" valign="top">randutils::mt19937_rng&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a6e93affa93ccff08bcbcb65f9897f65c">rng</a></td></tr>
<tr class="memdesc:a6e93affa93ccff08bcbcb65f9897f65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A neat random generator implemented in thirdparty/randutils.hpp, see <a href="https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html">https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html</a>.  <a href="classghost_1_1Objective.html#a6e93affa93ccff08bcbcb65f9897f65c">More...</a><br /></td></tr>
<tr class="separator:a6e93affa93ccff08bcbcb65f9897f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a135ddf4017f9df930c2790f5e40d46dc"><td class="memTemplParams" colspan="2">template&lt;typename ModelBuilderType &gt; </td></tr>
<tr class="memitem:a135ddf4017f9df930c2790f5e40d46dc"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a135ddf4017f9df930c2790f5e40d46dc">Solver</a></td></tr>
<tr class="separator:a135ddf4017f9df930c2790f5e40d46dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63fbc7633d606756d6105c27047d38"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a2c63fbc7633d606756d6105c27047d38">SearchUnit</a></td></tr>
<tr class="separator:a2c63fbc7633d606756d6105c27047d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c3d1f6a449713b2a45b269ff0dd07a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a77c3d1f6a449713b2a45b269ff0dd07a">ModelBuilder</a></td></tr>
<tr class="separator:a77c3d1f6a449713b2a45b269ff0dd07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffd60477e176d693bd41f531001dfbe"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a8ffd60477e176d693bd41f531001dfbe">NullObjective</a></td></tr>
<tr class="separator:a8ffd60477e176d693bd41f531001dfbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8056bd94aab05f9a4e5d2d656c317"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5cf8056bd94aab05f9a4e5d2d656c317">Minimize</a></td></tr>
<tr class="separator:a5cf8056bd94aab05f9a4e5d2d656c317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599f40e985bea17e0e8a6ef09c9a8b6a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a599f40e985bea17e0e8a6ef09c9a8b6a">Maximize</a></td></tr>
<tr class="separator:a599f40e985bea17e0e8a6ef09c9a8b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e7b267e1777cd5d882bec13e7e14d6"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a80e7b267e1777cd5d882bec13e7e14d6">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;o)</td></tr>
<tr class="memdesc:a80e7b267e1777cd5d882bec13e7e14d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">To have a nicer stream of <a class="el" href="classghost_1_1Objective.html">Objective</a>.  <a href="classghost_1_1Objective.html#a80e7b267e1777cd5d882bec13e7e14d6">More...</a><br /></td></tr>
<tr class="separator:a80e7b267e1777cd5d882bec13e7e14d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class containing the logic of objective functions. However, users would not derive their own <a class="el" href="classghost_1_1Objective.html">Objective</a> class directly from <a class="el" href="classghost_1_1Objective.html">ghost::Objective</a>, but from one of the two derived class <a class="el" href="classghost_1_1Minimize.html">ghost::Minimize</a> and <a class="el" href="classghost_1_1Maximize.html">ghost::Maximize</a>.</p>
<p>This class contains some methods prefixed by 'expert_'. It is highly recommended that users override such methods only if they know what they are doing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html">Variable</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7e2305f59de130a75785a1dc9269d7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2305f59de130a75785a1dc9269d7ae">&#9670;&nbsp;</a></span>Objective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy contructor. </p>

</div>
</div>
<a id="ae9d567c78a9df7aeae4f8bea71e54b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d567c78a9df7aeae4f8bea71e54b56">&#9670;&nbsp;</a></span>Objective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move contructor. </p>

</div>
</div>
<a id="a9b288b785eb9abd31389adffe0e82716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b288b785eb9abd31389adffe0e82716">&#9670;&nbsp;</a></span>~Objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ghost::Objective::~Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4eee4897bba29f5b14535cecb0afef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eee4897bba29f5b14535cecb0afef35">&#9670;&nbsp;</a></span>conditional_update_data_structures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::conditional_update_data_structures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update user-defined data structures in the objective function.</p>
<p>If some inner data structures are defined in derived objective classes and need to be updated while variable values change (i.e., when the solver asssign 'new_value' to variables[index]), this method must be implemented to define how data structures must be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables of the objective function. </td></tr>
    <tr><td class="paramname">index</td><td>an integer to get the variable 'variables[index]' that has been updated by the solver. </td></tr>
    <tr><td class="paramname">new_value</td><td>an integer to know what is the new value of 'variables[index]'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d49dd27a72571e874351c8f969d2d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d49dd27a72571e874351c8f969d2d43">&#9670;&nbsp;</a></span>expert_heuristic_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to apply the value heuristic used by the solver for non permutation problems.</p>
<p>While dealing with non permutation problems, the solver calls this method to apply an eventual user-defined heuristic to choose a new domain value for a variable selected by the solver.</p>
<p>The default implementation outputs the value leading to the lowest objective cost. If two or more values lead to configurations with the same lowest cost, one of them is randomly returned.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">variable_index</td><td>the index of the variable to change in the vector Objective::_variables. </td></tr>
    <tr><td class="paramname">possible_values</td><td>a const reference to the vector of possible values of the variable to change. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected value according to the heuristic. </dd></dl>

</div>
</div>
<a id="a74a9c2bc85b6878e282fa4acd4e91085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a9c2bc85b6878e282fa4acd4e91085">&#9670;&nbsp;</a></span>expert_heuristic_value_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_variables</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to apply the value heuristic used by the solver for permutation problems.</p>
<p>While dealing with permutation problems, the solver calls this method to apply an eventual user-defined heuristic to choose a variable to swap the value with.</p>
<p>By default, it returns a random variable from the bad_variables vector given as input.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">variable_index</td><td>the index of the variable to change in the vector Objective::_variables. </td></tr>
    <tr><td class="paramname">bad_variables</td><td>a const reference to the vector of candidate variables the solver may swap the value with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the selected variable to swap with, according to the heuristic. </dd></dl>

</div>
</div>
<a id="a10baf71ce9df56d6ad6a95878ca8cb96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10baf71ce9df56d6ad6a95878ca8cb96">&#9670;&nbsp;</a></span>expert_postprocess_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_optimization </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>best_cost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to perform optimization post-processing.</p>
<p>This method is called by the solver after all optimization runs to apply human-knowledge optimization, allowing to improve the optimization cost.</p>
<p>It does nothing by default. Users need to override it to have an optimization postprocess.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The computation spantime of this method is not taken into account by timeouts given to the solver. If users override this method, they must ensure its computation time is neglictable compare to the timeout giving as input to <a class="el" href="classghost_1_1Solver.html#a4c6003a8f3ba82ef0d9b7d0823c92c0f">Solver::solve</a>. <br  />
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">best_cost</td><td>a reference to the double representing the best optimization cost found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>a reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>postprocess_optimization </dd></dl>

</div>
</div>
<a id="a6892d6c1c168b4a089e0bbea394e4e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6892d6c1c168b4a089e0bbea394e4e62">&#9670;&nbsp;</a></span>expert_postprocess_satisfaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_satisfaction </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>best_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to perform satisfaction post-processing.</p>
<p>This method is called by the solver after a satisfaction run, if the solver was able to find a solution, to apply human-knowledge optimization in order to "clean-up" the proposed solution.</p>
<p>It does nothing by default. Users need to override it to have a satisfaction postprocess.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">best_error</td><td>a reference to the double representing the best satisfaction error found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>a reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>postprocess_satisfaction </dd></dl>

</div>
</div>
<a id="a783eec9b238077a2b2f1b95aa9b9610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783eec9b238077a2b2f1b95aa9b9610e">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ghost::Objective::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline accessor to get the name of the objective object. </p>

</div>
</div>
<a id="af4e2ff78a8bbaaf05db5a36e3e933023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2ff78a8bbaaf05db5a36e3e933023">&#9670;&nbsp;</a></span>is_maximization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghost::Objective::is_maximization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline method if the user-defined objective function has to be maximized (true) or minimize (false). </p>

</div>
</div>
<a id="ac49a9de70ecd5f26813a79db906a70f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49a9de70ecd5f26813a79db906a70f4">&#9670;&nbsp;</a></span>is_not_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::is_not_optimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adecd250b2a1c09c065942c4482b7b223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd250b2a1c09c065942c4482b7b223">&#9670;&nbsp;</a></span>is_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghost::Objective::is_optimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline method returning if a user-defined objective function has been declared. </p>

</div>
</div>
<a id="adaedfb85e62325aaa1ce766e60c93d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaedfb85e62325aaa1ce766e60c93d77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator disabled. </p>

</div>
</div>
<a id="a5682a026b25d9ca93cacf3d19f5ef0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5682a026b25d9ca93cacf3d19f5ef0ec">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator disabled. </p>

</div>
</div>
<a id="a8de169b534833805ae0073dc2ef22a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de169b534833805ae0073dc2ef22a6a">&#9670;&nbsp;</a></span>required_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Objective::required_cost </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual method to compute the value of the objective function regarding the values of variables given as input.</p>
<p>Like <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>, this method is fundamental: it evalutes the performance of the current values of the variables. GHOST will search for variable values that will minimize or maximize the output of this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double corresponding to the value of the objective function on the current configuration. Unlike <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>, this output may be negative. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is NaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a599f40e985bea17e0e8a6ef09c9a8b6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599f40e985bea17e0e8a6ef09c9a8b6a">&#9670;&nbsp;</a></span>Maximize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classghost_1_1Maximize.html">Maximize</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cf8056bd94aab05f9a4e5d2d656c317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf8056bd94aab05f9a4e5d2d656c317">&#9670;&nbsp;</a></span>Minimize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classghost_1_1Minimize.html">Minimize</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a77c3d1f6a449713b2a45b269ff0dd07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c3d1f6a449713b2a45b269ff0dd07a">&#9670;&nbsp;</a></span>ModelBuilder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classghost_1_1ModelBuilder.html">ModelBuilder</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ffd60477e176d693bd41f531001dfbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffd60477e176d693bd41f531001dfbe">&#9670;&nbsp;</a></span>NullObjective</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classghost_1_1NullObjective.html">NullObjective</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80e7b267e1777cd5d882bec13e7e14d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80e7b267e1777cd5d882bec13e7e14d6">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To have a nicer stream of <a class="el" href="classghost_1_1Objective.html">Objective</a>. </p>

</div>
</div>
<a id="a2c63fbc7633d606756d6105c27047d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63fbc7633d606756d6105c27047d38">&#9670;&nbsp;</a></span>SearchUnit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SearchUnit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a135ddf4017f9df930c2790f5e40d46dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135ddf4017f9df930c2790f5e40d46dc">&#9670;&nbsp;</a></span>Solver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ModelBuilderType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classghost_1_1Solver.html">Solver</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6e93affa93ccff08bcbcb65f9897f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e93affa93ccff08bcbcb65f9897f65c">&#9670;&nbsp;</a></span>rng</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">randutils::mt19937_rng ghost::Objective::rng</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A neat random generator implemented in thirdparty/randutils.hpp, see <a href="https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html">https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="objective_8hpp_source.html">objective.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 29 2021 13:22:59 for GHOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
