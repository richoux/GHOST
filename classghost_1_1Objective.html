<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Objective Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Objective.html">Objective</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classghost_1_1Objective-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Objective Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>This class encodes objective functions of your COP/CFN, as well as the special class NullObjective for CSP.  
 <a href="classghost_1_1Objective.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="objective_8hpp_source.html">objective.hpp</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__coll__graph.png" border="0" usemap="#ghost_1_1Objective_coll__map" alt="Collaboration graph"/></div>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30a595b146555401e98f51b5a1ef5bfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a30a595b146555401e98f51b5a1ef5bfb">Objective</a> (const string &amp;<a class="el" href="classghost_1_1Objective.html#af5bf0605c193884ad7f53593dabe8b85">name</a>)</td></tr>
<tr class="memdesc:a30a595b146555401e98f51b5a1ef5bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique constructor.  <a href="#a30a595b146555401e98f51b5a1ef5bfb">More...</a><br /></td></tr>
<tr class="separator:a30a595b146555401e98f51b5a1ef5bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2305f59de130a75785a1dc9269d7ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">Objective</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=default</td></tr>
<tr class="memdesc:a7e2305f59de130a75785a1dc9269d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <a href="#a7e2305f59de130a75785a1dc9269d7ae">More...</a><br /></td></tr>
<tr class="separator:a7e2305f59de130a75785a1dc9269d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">Objective</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <a href="#ae9d567c78a9df7aeae4f8bea71e54b56">More...</a><br /></td></tr>
<tr class="separator:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaedfb85e62325aaa1ce766e60c93d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">operator=</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=delete</td></tr>
<tr class="memdesc:adaedfb85e62325aaa1ce766e60c93d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <a href="#adaedfb85e62325aaa1ce766e60c93d77">More...</a><br /></td></tr>
<tr class="separator:adaedfb85e62325aaa1ce766e60c93d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">operator=</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <a href="#a5682a026b25d9ca93cacf3d19f5ef0ec">More...</a><br /></td></tr>
<tr class="separator:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b288b785eb9abd31389adffe0e82716"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">~Objective</a> ()=default</td></tr>
<tr class="separator:a9b288b785eb9abd31389adffe0e82716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69b61c650c007dd87c044084f9e733"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5b69b61c650c007dd87c044084f9e733">cost</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables) const</td></tr>
<tr class="memdesc:a5b69b61c650c007dd87c044084f9e733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling v_cost.  <a href="#a5b69b61c650c007dd87c044084f9e733">More...</a><br /></td></tr>
<tr class="separator:a5b69b61c650c007dd87c044084f9e733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a203853897805293c32c206a5b5bb0b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a203853897805293c32c206a5b5bb0b4e">heuristic_value</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, <a class="el" href="classghost_1_1Variable.html">Variable</a> &amp;var, const vector&lt; int &gt; &amp;possible_values) const</td></tr>
<tr class="memdesc:a203853897805293c32c206a5b5bb0b4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_heuristic_value.  <a href="#a203853897805293c32c206a5b5bb0b4e">More...</a><br /></td></tr>
<tr class="separator:a203853897805293c32c206a5b5bb0b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ad41fe7918a8dbce8662cf933ce3aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a17ad41fe7918a8dbce8662cf933ce3aa">heuristic_value</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;bad_variables) const</td></tr>
<tr class="memdesc:a17ad41fe7918a8dbce8662cf933ce3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_heuristic_value.  <a href="#a17ad41fe7918a8dbce8662cf933ce3aa">More...</a><br /></td></tr>
<tr class="separator:a17ad41fe7918a8dbce8662cf933ce3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a799a19352cbb68d3bd66c574c3200530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a799a19352cbb68d3bd66c574c3200530">postprocess_satisfaction</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="memdesc:a799a19352cbb68d3bd66c574c3200530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_postprocess_satisfaction.  <a href="#a799a19352cbb68d3bd66c574c3200530">More...</a><br /></td></tr>
<tr class="separator:a799a19352cbb68d3bd66c574c3200530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1760a4a671cb640fdbbb1e3c5e380e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a1760a4a671cb640fdbbb1e3c5e380e2d">postprocess_optimization</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="memdesc:a1760a4a671cb640fdbbb1e3c5e380e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline function following the NVI idiom. Calling expert_postprocess_optimization.  <a href="#a1760a4a671cb640fdbbb1e3c5e380e2d">More...</a><br /></td></tr>
<tr class="separator:a1760a4a671cb640fdbbb1e3c5e380e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a00cd379d76fb92f3c0559ebeba82"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a8a6a00cd379d76fb92f3c0559ebeba82">get_name</a> () const</td></tr>
<tr class="memdesc:a8a6a00cd379d76fb92f3c0559ebeba82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline accessor to get the name of the objective object.  <a href="#a8a6a00cd379d76fb92f3c0559ebeba82">More...</a><br /></td></tr>
<tr class="separator:a8a6a00cd379d76fb92f3c0559ebeba82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aae6630f4fca9012278a0bf1ca1503cd0"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#aae6630f4fca9012278a0bf1ca1503cd0">required_cost</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables) const =0</td></tr>
<tr class="memdesc:aae6630f4fca9012278a0bf1ca1503cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pure virtual function to compute the value of the objective function on the current configuration.  <a href="#aae6630f4fca9012278a0bf1ca1503cd0">More...</a><br /></td></tr>
<tr class="separator:aae6630f4fca9012278a0bf1ca1503cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb2175089b546197df941328babc43"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#aa3bb2175089b546197df941328babc43">expert_heuristic_value</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, <a class="el" href="classghost_1_1Variable.html">Variable</a> &amp;var, const vector&lt; int &gt; &amp;possible_values) const</td></tr>
<tr class="memdesc:aa3bb2175089b546197df941328babc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to apply the value heuristic used by the solver for non permutation problems.  <a href="#aa3bb2175089b546197df941328babc43">More...</a><br /></td></tr>
<tr class="separator:aa3bb2175089b546197df941328babc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742f20c1f6474a7cf1362041a541a84b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classghost_1_1Variable.html">Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a742f20c1f6474a7cf1362041a541a84b">expert_heuristic_value</a> (const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;bad_variables) const</td></tr>
<tr class="memdesc:a742f20c1f6474a7cf1362041a541a84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to apply the value heuristic used by the solver for permutation problems.  <a href="#a742f20c1f6474a7cf1362041a541a84b">More...</a><br /></td></tr>
<tr class="separator:a742f20c1f6474a7cf1362041a541a84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d0e06072e4167d6c2fd4df533fea9b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ad8d0e06072e4167d6c2fd4df533fea9b">expert_postprocess_satisfaction</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="memdesc:ad8d0e06072e4167d6c2fd4df533fea9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to perform satisfaction post-processing.  <a href="#ad8d0e06072e4167d6c2fd4df533fea9b">More...</a><br /></td></tr>
<tr class="separator:ad8d0e06072e4167d6c2fd4df533fea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5cf932197c5d1ac4569a176e1f9eef"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#acc5cf932197c5d1ac4569a176e1f9eef">expert_postprocess_optimization</a> (vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;variables, double &amp;bestCost, vector&lt; int &gt; &amp;solution) const</td></tr>
<tr class="memdesc:acc5cf932197c5d1ac4569a176e1f9eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual function to perform optimization post-processing.  <a href="#acc5cf932197c5d1ac4569a176e1f9eef">More...</a><br /></td></tr>
<tr class="separator:acc5cf932197c5d1ac4569a176e1f9eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6e93affa93ccff08bcbcb65f9897f65c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacerandutils.html#a7ad409d0cae7ed019fd23cc64e3f764f">randutils::mt19937_rng</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a6e93affa93ccff08bcbcb65f9897f65c">rng</a></td></tr>
<tr class="memdesc:a6e93affa93ccff08bcbcb65f9897f65c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A neat random generator from <a class="el" href="randutils_8hpp.html">randutils.hpp</a>.  <a href="#a6e93affa93ccff08bcbcb65f9897f65c">More...</a><br /></td></tr>
<tr class="separator:a6e93affa93ccff08bcbcb65f9897f65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf0605c193884ad7f53593dabe8b85"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af5bf0605c193884ad7f53593dabe8b85">name</a></td></tr>
<tr class="memdesc:af5bf0605c193884ad7f53593dabe8b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">String for the name of the objective object.  <a href="#af5bf0605c193884ad7f53593dabe8b85">More...</a><br /></td></tr>
<tr class="separator:af5bf0605c193884ad7f53593dabe8b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class encodes objective functions of your COP/CFN, as well as the special class NullObjective for CSP. </p>
<p>In GHOST, many different objective objects can be instanciate.</p>
<p>You cannot directly use this class <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> to encode your objective functions since this is an abstract class. Thus, you must write your own objective class inheriting from <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">ghost::Objective</a>. You can write different objective classes to model your problem, and switch from an objective to another between two <a class="el" href="classghost_1_1Solver.html#a31d21dccc6a803452a81839495294019" title="Solver&#39;s main function, to solve the given CSP/COP/CFN. ">Solver::solve</a> calls.</p>
<p>In this class, each virtual function follows the Non-Virtual Interface Idiom (see <a href="http://www.gotw.ca/publications/mill18.htm">http://www.gotw.ca/publications/mill18.htm</a>). The only pure virtual function is required_cost. All other virtual functions have a default behavior implemented and are prefixed by 'expert_'. It is highly recommended to override these functions only if you know what you are doing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html" title="This class encodes variables of your CSP/COP/CFN. You cannot inherits your own class from Variable...">Variable</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a30a595b146555401e98f51b5a1ef5bfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a595b146555401e98f51b5a1ef5bfb">&#9670;&nbsp;</a></span>Objective() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unique constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A const reference to a string to give the <a class="el" href="classghost_1_1Objective.html" title="This class encodes objective functions of your COP/CFN, as well as the special class NullObjective fo...">Objective</a> object a specific name. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e2305f59de130a75785a1dc9269d7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2305f59de130a75785a1dc9269d7ae">&#9670;&nbsp;</a></span>Objective() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy contructor. </p>

</div>
</div>
<a id="ae9d567c78a9df7aeae4f8bea71e54b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d567c78a9df7aeae4f8bea71e54b56">&#9670;&nbsp;</a></span>Objective() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move contructor. </p>

</div>
</div>
<a id="a9b288b785eb9abd31389adffe0e82716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b288b785eb9abd31389adffe0e82716">&#9670;&nbsp;</a></span>~Objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ghost::Objective::~Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5b69b61c650c007dd87c044084f9e733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b69b61c650c007dd87c044084f9e733">&#9670;&nbsp;</a></span>cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ghost::Objective::cost </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling v_cost. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">nanException</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#aae6630f4fca9012278a0bf1ca1503cd0" title="Pure virtual function to compute the value of the objective function on the current configuration...">required_cost</a> </dd></dl>

</div>
</div>
<a id="aa3bb2175089b546197df941328babc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bb2175089b546197df941328babc43">&#9670;&nbsp;</a></span>expert_heuristic_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classghost_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to apply the value heuristic used by the solver for non permutation problems. </p>
<p>While dealing with non permutation problems, the solver calls this function to apply an eventual user-defined heuristic to choose a new domain value for a variable selected by the solver.</p>
<p>The default implementation outputs the value leading to the lowest objective cost. If two or more values lead to configurations with the same lowest cost, one of them is randomly returned.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A const reference to the vector containing all variables. </td></tr>
    <tr><td class="paramname">var</td><td>A reference to the variable to change. </td></tr>
    <tr><td class="paramname">possible_values</td><td>A const reference to the vector of possible values of var. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected value according to the heuristic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a203853897805293c32c206a5b5bb0b4e" title="Inline function following the NVI idiom. Calling expert_heuristic_value. ">heuristic_value</a> </dd></dl>

</div>
</div>
<a id="a742f20c1f6474a7cf1362041a541a84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742f20c1f6474a7cf1362041a541a84b">&#9670;&nbsp;</a></span>expert_heuristic_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classghost_1_1Variable.html">Variable</a>* ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to apply the value heuristic used by the solver for permutation problems. </p>
<p>While dealing with permutation problems, the solver calls this function to apply an eventual user-defined heuristic to choose a variable to swap the value with.</p>
<p>By default, it returns a random variable among the vector in input.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bad_variables</td><td>A const reference to the vector of pointers to candidate variables the solver may swap the value with another variable it had chosen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The address of the selected variable to swap with, according to the heuristic. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a203853897805293c32c206a5b5bb0b4e" title="Inline function following the NVI idiom. Calling expert_heuristic_value. ">heuristic_value</a> </dd></dl>

</div>
</div>
<a id="acc5cf932197c5d1ac4569a176e1f9eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5cf932197c5d1ac4569a176e1f9eef">&#9670;&nbsp;</a></span>expert_postprocess_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_optimization </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to perform optimization post-processing. </p>
<p>This function is called by the solver after all optimization runs to apply human-knowledge optimization, allowing to improve the optimization cost.</p>
<p>It does nothing by default. You need to override it to have an optimization postprocess.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The computation spantime of this function is not taken into account by timeouts given to the solver. If you override this function, be sure its computation time is neglictable compare to the optimization timeout you give to <a class="el" href="classghost_1_1Solver.html#a31d21dccc6a803452a81839495294019" title="Solver&#39;s main function, to solve the given CSP/COP/CFN. ">Solver::solve</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A reference to the vector of variables of the CSP/COP/CFN. </td></tr>
    <tr><td class="paramname">bestCost</td><td>A reference to the double representing the best optimization cost found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>A reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a1760a4a671cb640fdbbb1e3c5e380e2d" title="Inline function following the NVI idiom. Calling expert_postprocess_optimization. ...">postprocess_optimization</a> </dd></dl>

</div>
</div>
<a id="ad8d0e06072e4167d6c2fd4df533fea9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d0e06072e4167d6c2fd4df533fea9b">&#9670;&nbsp;</a></span>expert_postprocess_satisfaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::expert_postprocess_satisfaction </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual function to perform satisfaction post-processing. </p>
<p>This function is called by the solver after a satisfaction run, if the solver was able to find a solution, to apply human-knowledge optimization in order to "clean-up" the proposed solution.</p>
<p>It does nothing by default. You need to override it to have a satisfaction postprocess.</p>
<p>Like all functions prefixed by 'expert_', you should override this function only if you know what you are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A reference to the vector of variables of the CSP/COP/CFN. </td></tr>
    <tr><td class="paramname">bestCost</td><td>A reference to the double representing the best satisfaction cost found by the solver so far. Its value may be updated, justifying a non const reference. </td></tr>
    <tr><td class="paramname">solution</td><td>A reference to the vector of variables of the solution found by the solver. This vector may be updated, justifying a non const reference </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a799a19352cbb68d3bd66c574c3200530" title="Inline function following the NVI idiom. Calling expert_postprocess_satisfaction. ...">postprocess_satisfaction</a> </dd></dl>

</div>
</div>
<a id="a8a6a00cd379d76fb92f3c0559ebeba82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6a00cd379d76fb92f3c0559ebeba82">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string ghost::Objective::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline accessor to get the name of the objective object. </p>

</div>
</div>
<a id="a203853897805293c32c206a5b5bb0b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a203853897805293c32c206a5b5bb0b4e">&#9670;&nbsp;</a></span>heuristic_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ghost::Objective::heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classghost_1_1Variable.html">Variable</a> &amp;&#160;</td>
          <td class="paramname"><em>var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_heuristic_value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#aa3bb2175089b546197df941328babc43" title="Virtual function to apply the value heuristic used by the solver for non permutation problems...">expert_heuristic_value</a> </dd></dl>

</div>
</div>
<a id="a17ad41fe7918a8dbce8662cf933ce3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ad41fe7918a8dbce8662cf933ce3aa">&#9670;&nbsp;</a></span>heuristic_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Variable.html">Variable</a>* ghost::Objective::heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_heuristic_value. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#aa3bb2175089b546197df941328babc43" title="Virtual function to apply the value heuristic used by the solver for non permutation problems...">expert_heuristic_value</a> </dd></dl>

</div>
</div>
<a id="adaedfb85e62325aaa1ce766e60c93d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaedfb85e62325aaa1ce766e60c93d77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator disabled. </p>

</div>
</div>
<a id="a5682a026b25d9ca93cacf3d19f5ef0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5682a026b25d9ca93cacf3d19f5ef0ec">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator disabled. </p>

</div>
</div>
<a id="a1760a4a671cb640fdbbb1e3c5e380e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1760a4a671cb640fdbbb1e3c5e380e2d">&#9670;&nbsp;</a></span>postprocess_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::postprocess_optimization </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_postprocess_optimization. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#acc5cf932197c5d1ac4569a176e1f9eef" title="Virtual function to perform optimization post-processing. ">expert_postprocess_optimization</a> </dd></dl>

</div>
</div>
<a id="a799a19352cbb68d3bd66c574c3200530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a799a19352cbb68d3bd66c574c3200530">&#9670;&nbsp;</a></span>postprocess_satisfaction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::postprocess_satisfaction </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>bestCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline function following the NVI idiom. Calling expert_postprocess_satisfaction. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#ad8d0e06072e4167d6c2fd4df533fea9b" title="Virtual function to perform satisfaction post-processing. ">expert_postprocess_satisfaction</a> </dd></dl>

</div>
</div>
<a id="aae6630f4fca9012278a0bf1ca1503cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae6630f4fca9012278a0bf1ca1503cd0">&#9670;&nbsp;</a></span>required_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Objective::required_cost </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pure virtual function to compute the value of the objective function on the current configuration. </p>
<p>Like <a class="el" href="classghost_1_1Constraint.html#a6ef4cd03a4dc864a8d308e55044c615d" title="Pure virtual function to compute the current cost of the constraint. ">Constraint::required_cost</a>, this function is fundamental: it evalutes the performance of the current values of the variables. GHOST will search for variable values that will minimize the output of this function. If you are modelling a maximization problem, ie, a problem where its natural objective function f(x) = z is to try to find the highest possible z, you can simplify write this function such that it outputs -z. Values of variables minimizing -z will also maximize z.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>A const reference to the vector of variable of the CSP/COP/CFN. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double corresponding to the value of the objective function on the current configuration. Unlike <a class="el" href="classghost_1_1Constraint.html#a6ef4cd03a4dc864a8d308e55044c615d" title="Pure virtual function to compute the current cost of the constraint. ">Constraint::required_cost</a>, this output may be negative. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Objective.html#a5b69b61c650c007dd87c044084f9e733" title="Inline function following the NVI idiom. Calling v_cost. ">cost</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af5bf0605c193884ad7f53593dabe8b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bf0605c193884ad7f53593dabe8b85">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string ghost::Objective::name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>String for the name of the objective object. </p>

</div>
</div>
<a id="a6e93affa93ccff08bcbcb65f9897f65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e93affa93ccff08bcbcb65f9897f65c">&#9670;&nbsp;</a></span>rng</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacerandutils.html#a7ad409d0cae7ed019fd23cc64e3f764f">randutils::mt19937_rng</a> ghost::Objective::rng</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A neat random generator from <a class="el" href="randutils_8hpp.html">randutils.hpp</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="objective_8hpp_source.html">objective.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 16 2020 15:40:10 for GHOST by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
