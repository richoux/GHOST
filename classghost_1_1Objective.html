<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GHOST: ghost::Objective Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GHOST
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceghost.html">ghost</a></li><li class="navelem"><a class="el" href="classghost_1_1Objective.html">Objective</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classghost_1_1Objective-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ghost::Objective Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="objective_8hpp_source.html">objective.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__inherit__graph.png" border="0" usemap="#aghost_1_1Objective_inherit__map" alt="Inheritance graph"/></div>
<map name="aghost_1_1Objective_inherit__map" id="aghost_1_1Objective_inherit__map">
<area shape="rect" title=" " alt="" coords="121,5,291,303"/>
<area shape="rect" href="classghost_1_1Maximize.html" title=" " alt="" coords="5,351,124,501"/>
<area shape="rect" href="classghost_1_1Minimize.html" title=" " alt="" coords="149,351,263,501"/>
<area shape="rect" title=" " alt="" coords="288,387,428,465"/>
</map>
</div>
<div class="dynheader">
Collaboration diagram for ghost::Objective:</div>
<div class="dyncontent">
<div class="center"><img src="classghost_1_1Objective__coll__graph.png" border="0" usemap="#aghost_1_1Objective_coll__map" alt="Collaboration graph"/></div>
<map name="aghost_1_1Objective_coll__map" id="aghost_1_1Objective_coll__map">
<area shape="rect" title=" " alt="" coords="5,5,176,303"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e2305f59de130a75785a1dc9269d7ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">Objective</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=default</td></tr>
<tr class="memdesc:a7e2305f59de130a75785a1dc9269d7ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default copy contructor.  <a href="classghost_1_1Objective.html#a7e2305f59de130a75785a1dc9269d7ae">More...</a><br /></td></tr>
<tr class="separator:a7e2305f59de130a75785a1dc9269d7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">Objective</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=default</td></tr>
<tr class="memdesc:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default move contructor.  <a href="classghost_1_1Objective.html#ae9d567c78a9df7aeae4f8bea71e54b56">More...</a><br /></td></tr>
<tr class="separator:ae9d567c78a9df7aeae4f8bea71e54b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaedfb85e62325aaa1ce766e60c93d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">operator=</a> (const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;other)=delete</td></tr>
<tr class="memdesc:adaedfb85e62325aaa1ce766e60c93d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator disabled.  <a href="classghost_1_1Objective.html#adaedfb85e62325aaa1ce766e60c93d77">More...</a><br /></td></tr>
<tr class="separator:adaedfb85e62325aaa1ce766e60c93d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">operator=</a> (<a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;other)=delete</td></tr>
<tr class="memdesc:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator disabled.  <a href="classghost_1_1Objective.html#a5682a026b25d9ca93cacf3d19f5ef0ec">More...</a><br /></td></tr>
<tr class="separator:a5682a026b25d9ca93cacf3d19f5ef0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b288b785eb9abd31389adffe0e82716"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">~Objective</a> ()=default</td></tr>
<tr class="memdesc:a9b288b785eb9abd31389adffe0e82716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <a href="classghost_1_1Objective.html#a9b288b785eb9abd31389adffe0e82716">More...</a><br /></td></tr>
<tr class="separator:a9b288b785eb9abd31389adffe0e82716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783eec9b238077a2b2f1b95aa9b9610e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a783eec9b238077a2b2f1b95aa9b9610e">get_name</a> () const</td></tr>
<tr class="memdesc:a783eec9b238077a2b2f1b95aa9b9610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline accessor to get the name of the objective object.  <a href="classghost_1_1Objective.html#a783eec9b238077a2b2f1b95aa9b9610e">More...</a><br /></td></tr>
<tr class="separator:a783eec9b238077a2b2f1b95aa9b9610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecd250b2a1c09c065942c4482b7b223"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#adecd250b2a1c09c065942c4482b7b223">is_optimization</a> () const</td></tr>
<tr class="memdesc:adecd250b2a1c09c065942c4482b7b223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inline method returning if a user-defined objective function has been declared.  <a href="classghost_1_1Objective.html#adecd250b2a1c09c065942c4482b7b223">More...</a><br /></td></tr>
<tr class="separator:adecd250b2a1c09c065942c4482b7b223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2ff78a8bbaaf05db5a36e3e933023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#af4e2ff78a8bbaaf05db5a36e3e933023">is_maximization</a> () const</td></tr>
<tr class="separator:af4e2ff78a8bbaaf05db5a36e3e933023"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8de169b534833805ae0073dc2ef22a6a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a8de169b534833805ae0073dc2ef22a6a">required_cost</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables) const =0</td></tr>
<tr class="separator:a8de169b534833805ae0073dc2ef22a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eee4897bba29f5b14535cecb0afef35"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a4eee4897bba29f5b14535cecb0afef35">conditional_update_data_structures</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int index, int new_value)</td></tr>
<tr class="separator:a4eee4897bba29f5b14535cecb0afef35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb937a9ed7fcd1924bf0689b5606cb9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a8fb937a9ed7fcd1924bf0689b5606cb9">expert_heuristic_value</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int variable_index, const std::vector&lt; int &gt; &amp;possible_values, randutils::mt19937_rng &amp;rng) const</td></tr>
<tr class="separator:a8fb937a9ed7fcd1924bf0689b5606cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741938594779fe9675d38344d4b1dca0"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a741938594779fe9675d38344d4b1dca0">expert_heuristic_value_permutation</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, int variable_index, const std::vector&lt; int &gt; &amp;bad_variables, randutils::mt19937_rng &amp;rng) const</td></tr>
<tr class="separator:a741938594779fe9675d38344d4b1dca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ef6272e6ef2275ef97bca32514aaee"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#a79ef6272e6ef2275ef97bca32514aaee">expert_postprocess</a> (const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;variables, double best_cost) const</td></tr>
<tr class="separator:a79ef6272e6ef2275ef97bca32514aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a9de70ecd5f26813a79db906a70f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classghost_1_1Objective.html#ac49a9de70ecd5f26813a79db906a70f4">is_not_optimization</a> ()</td></tr>
<tr class="separator:ac49a9de70ecd5f26813a79db906a70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the base class containing the logic of objective functions. However, users would not derive their own <a class="el" href="classghost_1_1Objective.html">Objective</a> class directly from <a class="el" href="classghost_1_1Objective.html">ghost::Objective</a>, but from one of the two derived class <a class="el" href="classghost_1_1Minimize.html">ghost::Minimize</a> and <a class="el" href="classghost_1_1Maximize.html">ghost::Maximize</a>.</p>
<p>This class contains some methods prefixed by 'expert_'. It is highly recommended that users override such methods only if they know what they are doing.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classghost_1_1Variable.html">Variable</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7e2305f59de130a75785a1dc9269d7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2305f59de130a75785a1dc9269d7ae">&#9670;&nbsp;</a></span>Objective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default copy contructor. </p>

</div>
</div>
<a id="ae9d567c78a9df7aeae4f8bea71e54b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d567c78a9df7aeae4f8bea71e54b56">&#9670;&nbsp;</a></span>Objective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ghost::Objective::Objective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default move contructor. </p>

</div>
</div>
<a id="a9b288b785eb9abd31389adffe0e82716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b288b785eb9abd31389adffe0e82716">&#9670;&nbsp;</a></span>~Objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ghost::Objective::~Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4eee4897bba29f5b14535cecb0afef35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eee4897bba29f5b14535cecb0afef35">&#9670;&nbsp;</a></span>conditional_update_data_structures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ghost::Objective::conditional_update_data_structures </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update user-defined data structures in the objective function.</p>
<p>Like any methods prefixed by 'conditional_', this method must be overriden under some conditions: if some inner data structures are defined in derived objective classes and need to be updated while variable values change (i.e., when the solver asssign 'new_value' to variables[index]), this method must be implemented to define how data structures must be updated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables of the objective function. </td></tr>
    <tr><td class="paramname">index</td><td>an integer to get the variable 'variables[index]' that has been updated by the solver. </td></tr>
    <tr><td class="paramname">new_value</td><td>an integer to know what is the new value of 'variables[index]'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fb937a9ed7fcd1924bf0689b5606cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb937a9ed7fcd1924bf0689b5606cb9">&#9670;&nbsp;</a></span>expert_heuristic_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>possible_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">randutils::mt19937_rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to apply the value heuristic used by the solver for non permutation problems.</p>
<p>While dealing with non permutation problems, the solver calls this method to apply an eventual user-defined heuristic to choose a new domain value for a variable selected by the solver.</p>
<p>The default implementation outputs the value leading to the lowest objective cost. If two or more values lead to configurations with the same lowest cost, one of them is randomly returned.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">variable_index</td><td>the index of the variable to change in the vector Objective::_variables. </td></tr>
    <tr><td class="paramname">possible_values</td><td>a const reference to the vector of possible values of the variable to change. </td></tr>
    <tr><td class="paramname">rng</td><td>a neat random generator implemented in thirdparty/randutils.hpp, see <a href="https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html">https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The selected value according to the heuristic. </dd></dl>

</div>
</div>
<a id="a741938594779fe9675d38344d4b1dca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a741938594779fe9675d38344d4b1dca0">&#9670;&nbsp;</a></span>expert_heuristic_value_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ghost::Objective::expert_heuristic_value_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>variable_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>bad_variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">randutils::mt19937_rng &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to apply the value heuristic used by the solver for permutation problems.</p>
<p>While dealing with permutation problems, the solver calls this method to apply an eventual user-defined heuristic to choose a variable to swap the value with.</p>
<p>By default, it returns a random variable from the bad_variables vector given as input.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. </td></tr>
    <tr><td class="paramname">variable_index</td><td>the index of the variable to change in the vector Objective::_variables. </td></tr>
    <tr><td class="paramname">bad_variables</td><td>a const reference to the vector of candidate variables the solver may swap the value with. </td></tr>
    <tr><td class="paramname">rng</td><td>a neat random generator implemented in thirdparty/randutils.hpp, see <a href="https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html">https://www.pcg-random.org/posts/ease-of-use-without-loss-of-power.html</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the selected variable to swap with, according to the heuristic. </dd></dl>

</div>
</div>
<a id="a79ef6272e6ef2275ef97bca32514aaee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ef6272e6ef2275ef97bca32514aaee">&#9670;&nbsp;</a></span>expert_postprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Objective::expert_postprocess </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>best_cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Virtual method to perform post-processing optimization.</p>
<p>This method is called by the solver once it has found a solution. Its purpose is to apply human-knowledge optimization.</p>
<p>By default, it simply returns best_cost given as input, without modifying the variables. Users need to override it to have their own post-processing optimization.</p>
<p>Like any methods prefixed by 'expert_', users should override this method only if they know what they are doing.</p>
<dl class="section warning"><dt>Warning</dt><dd>The computation spantime of this method is not taken into account by timeouts given to the solver. If users override this method, they must ensure its computation time is neglictable compare to the timeout giving as input to Solver::solve.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers of variables in the scope of the objective function. The solver is calling this method with the vector of variables that has been given to the constructor. If users must change some variables values, they must do it on variables from this vector, otherwise the modified solution won't be taken into account by the solver. </td></tr>
    <tr><td class="paramname">best_cost</td><td>a double representing the best optimization cost found by the solver so far. This helps users be sure that their post-processing leads to actual improvements. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new error after post-processing. </dd></dl>

</div>
</div>
<a id="a783eec9b238077a2b2f1b95aa9b9610e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783eec9b238077a2b2f1b95aa9b9610e">&#9670;&nbsp;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string ghost::Objective::get_name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline accessor to get the name of the objective object. </p>

</div>
</div>
<a id="af4e2ff78a8bbaaf05db5a36e3e933023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2ff78a8bbaaf05db5a36e3e933023">&#9670;&nbsp;</a></span>is_maximization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghost::Objective::is_maximization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inline method if the user-defined objective function has to be maximized (true) or minimize (false). </p>

</div>
</div>
<a id="ac49a9de70ecd5f26813a79db906a70f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49a9de70ecd5f26813a79db906a70f4">&#9670;&nbsp;</a></span>is_not_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ghost::Objective::is_not_optimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adecd250b2a1c09c065942c4482b7b223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecd250b2a1c09c065942c4482b7b223">&#9670;&nbsp;</a></span>is_optimization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ghost::Objective::is_optimization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inline method returning if a user-defined objective function has been declared. </p>

</div>
</div>
<a id="adaedfb85e62325aaa1ce766e60c93d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaedfb85e62325aaa1ce766e60c93d77">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator disabled. </p>

</div>
</div>
<a id="a5682a026b25d9ca93cacf3d19f5ef0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5682a026b25d9ca93cacf3d19f5ef0ec">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classghost_1_1Objective.html">Objective</a>&amp; ghost::Objective::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classghost_1_1Objective.html">Objective</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator disabled. </p>

</div>
</div>
<a id="a8de169b534833805ae0073dc2ef22a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de169b534833805ae0073dc2ef22a6a">&#9670;&nbsp;</a></span>required_cost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double ghost::Objective::required_cost </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classghost_1_1Variable.html">Variable</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variables</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pure virtual method to compute the value of the objective function regarding the values of variables given as input.</p>
<p>Like <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>, this method is fundamental: it evalutes the performance of the current values of the variables. GHOST will search for variable values that will minimize or maximize the output of this method.</p>
<p>Like any methods prefixed by 'required_', overriding this method is mandatory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variables</td><td>a const reference of the vector of raw pointers to variables in the scope of the constraint. The solver is actually calling this method with the vector of variables that has been given to the constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A double corresponding to the value of the objective function on the current configuration. Unlike <a class="el" href="classghost_1_1Constraint.html#a99bfdee12754330fd394ab4efbd93b41">Constraint::required_error</a>, this output may be negative. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Throws</td><td>an exception if the computed value is NaN. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="objective_8hpp_source.html">objective.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Sep 20 2023 18:43:24 for GHOST by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
